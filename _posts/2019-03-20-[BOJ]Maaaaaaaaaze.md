---
layout:     post
title:      "[BOJ]16985 Maaaaaaaaaze<다시풀기>"
subtitle:   ""
date:       2019-03-20 16:12:00
author:     "kyoungIn"
header-type: "text"
tags:
    - Algorithm
    - BOJ
---

# Maaaaaaaaaze <다시풀기>

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 512 MB      | 462  | 304  | 154       | 63.900%   |

## 문제

평화롭게 문제를 경작하며 생활하는 BOJ 마을 사람들은 더 이상 2차원 미로에 흥미를 느끼지 않는다. 2차원 미로는 너무나 쉽게 탈출이 가능하기 때문이다. 미로를 이 세상 그 누구보다 사랑하는 준현이는 이런 상황을 매우 안타깝게 여겨 아주 큰 상금을 걸고 BOJ 마을 사람들의 관심을 확 끌 수 있는 3차원 미로 탈출 대회를 개최하기로 했다.

대회의 규칙은 아래와 같다.

- 5×5 크기의 판이 5개 주어진다. 이중 일부 칸은 참가자가 들어갈 수 있고 일부 칸은 참가자가 들어갈 수 없다. 그림에서 하얀 칸은 참가자가 들어갈 수 있는 칸을, 검은 칸은 참가자가 들어갈 수 없는 칸을 의미한다.

![img](https://upload.acmicpc.net/cd5b0b7c-6030-4c55-8776-2c7561cd5a73/-/preview/)

- 참가자는 주어진 판들을 시계 방향, 혹은 반시계 방향으로 자유롭게 회전할 수 있다. 그러나 판을 뒤집을 수는 없다.

![img](https://upload.acmicpc.net/30dd4bb6-660a-4294-8dc3-a7cc348c307e/-/preview/)

- 회전을 완료한 후 참가자는 판 5개를 쌓는다. 판을 쌓는 순서는 참가자가 자유롭게 정할 수 있다. 이렇게 판 5개를 쌓아 만들어진 5×5×5 크기의 큐브가 바로 참가자를 위한 미로이다. 이 때 큐브의 입구는 정육면체에서 참가자가 임의로 선택한 꼭짓점에 위치한 칸이고 출구는 입구와 면을 공유하지 않는 꼭짓점에 위치한 칸이다.

![img](https://upload.acmicpc.net/6b66d051-d9fa-43a1-8cf1-53a635f9217d/-/preview/)

- 참가자는 현재 위치한 칸에서 면으로 인접한 칸이 참가자가 들어갈 수 있는 칸인 경우 그 칸으로 이동할 수 있다.
- 참가자 중에서 본인이 설계한 미로를 가장 적은 이동 횟수로 탈출한 사람이 우승한다. 만약 미로의 입구 혹은 출구가 막혀있거나, 입구에서 출구에 도달할 수 있는 방법이 존재하지 않을 경우에는 탈출이 불가능한 것으로 간주한다.

이 대회에서 우승하기 위해서는 미로를 잘 빠져나올 수 있기 위한 담력 증진과 체력 훈련, 그리고 적절한 운이 제일 중요하지만, 가장 적은 이동 횟수로 출구에 도달할 수 있게끔 미로를 만드는 능력 또한 없어서는 안된다. 주어진 판에서 가장 적은 이동 횟수로 출구에 도달할 수 있게끔 미로를 만들었을 때 몇 번 이동을 해야하는지 구해보자. 

## 입력

첫째 줄부터 25줄에 걸쳐 판이 주어진다. 각 판은 5줄에 걸쳐 주어지며 각 줄에는 5개의 숫자가 빈칸을 사이에 두고 주어진다. 0은 참가자가 들어갈 수 없는 칸, 1은 참가자가 들어갈 수 있는 칸을 의미한다.

## 출력

첫째 줄에 주어진 판으로 설계된 미로를 탈출하는 가장 적은 이동 횟수를 출력한다. 단, 어떻게 설계하더라도 탈출이 불가능할 경우에는 -1을 출력한다.

## 예제 입력 1 

```
1 1 1 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
```

## 예제 출력 1 

```
12
```

## 예제 입력 2 

```
1 1 1 1 1
1 0 0 0 1
1 0 0 0 1
1 0 0 0 1
1 1 1 1 1
0 0 0 0 0
0 1 1 1 0
0 1 0 1 0
0 1 1 1 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 1 1 1 0
0 1 0 1 0
0 1 1 1 0
0 0 0 0 0
1 1 1 1 1
1 0 0 0 1
1 0 0 0 1
1 0 0 0 1
1 1 1 1 1
```

## 예제 출력 2 

```
-1
```

## 예제 입력 3 

```
1 1 1 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1
```

## 예제 출력 3 

```
12
```

## 예제 입력 4 

```
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
```

## 예제 출력 4 

```
12
```

## 예제 입력 5 

```
0 0 0 1 0
0 0 0 0 0
1 0 1 1 1
0 0 0 1 0
0 0 1 0 0
0 1 0 0 0
1 1 0 0 0
1 0 0 1 0
0 1 1 1 0
0 1 0 1 0
0 0 1 0 0
1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
1 1 1 0 0
1 0 0 0 1
1 0 0 0 0
0 0 1 0 1
0 1 1 0 0
0 1 0 0 0
0 0 0 1 0
1 0 0 0 0
0 0 1 0 0
0 1 0 0 1
0 1 0 0 0
```

## 예제 출력 5 

```
22
```

## 예제 입력 6 

```
0 0 0 0 0
0 0 0 0 0
1 0 0 0 1
0 0 1 0 0
0 0 1 1 1
0 1 0 0 1
0 0 0 0 1
0 0 0 0 0
0 0 0 0 0
0 1 0 0 0
0 1 0 0 1
1 0 0 1 0
0 0 0 1 0
0 1 1 0 0
0 1 0 0 0
1 0 1 0 0
0 0 0 0 0
1 0 0 0 0
0 0 0 1 0
1 0 0 0 0
0 0 0 1 0
0 0 0 0 1
1 1 0 0 0
1 0 0 1 1
1 0 0 0 0
```

## 예제 출력 6 

```
-1
```

## 예제 입력 7 

```
1 1 0 0 0
0 0 0 0 1
0 0 1 0 0
0 0 0 0 0
0 0 0 0 0
0 0 1 1 1
1 0 0 0 0
0 0 1 0 0
0 0 1 1 1
0 0 1 0 0
0 0 0 0 0
0 0 1 0 1
0 0 0 0 0
0 0 0 1 0
0 0 1 0 1
0 0 1 0 0
1 0 0 0 0
0 0 1 1 0
1 0 1 0 0
0 0 1 0 1
0 0 1 1 0
1 1 0 1 1
0 0 0 0 1
0 1 0 1 0
0 1 0 0 0
```

## 예제 출력 7 

```
16
```

## 예제 입력 8 복사

```
0 0 1 0 0
0 0 0 0 0
1 1 0 0 0
0 0 1 0 0
1 1 1 0 0
0 0 0 0 1
1 0 0 0 0
0 1 0 0 1
0 0 0 0 0
0 1 0 1 0
1 0 0 0 1
1 1 1 1 1
1 1 0 0 0
0 0 0 1 0
0 0 0 1 0
0 0 0 1 1
0 0 1 0 0
0 1 1 1 0
1 0 0 0 0
0 1 1 0 1
0 1 0 0 0
0 0 0 1 0
1 0 0 0 0
0 0 0 1 0
0 0 0 1 0
```

## 예제 출력 8 복사

```
18
```

## 풀이 <다시풀기>



```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
#include <queue>
using namespace std;
#define p pair<int,int>
#define pp pair<p,p>
int map[4][5][5][5],data[5][5][5];
vector<vector<int>>v;
int dy[]={-1,0,1,0,0,0},dx[]={0,1,0,-1,0,0},dz[]={0,0,0,0,-1,1};
int ans=100000;

void bfs(int sz,int sy,int sx,int ez,int ey,int ex){
    int visit[5][5][5]={0};
    queue<pp> q;
    q.push(pp(p(sz,sy),p(sx,0)));
    visit[sz][sy][sx]=1;
    while(!q.empty()){
        int z= q.front().first.first;
        int y= q.front().first.second;
        int x= q.front().second.first;
        int cnt = q.front().second.second;
        q.pop();
        for(int i=0;i<6;i++){
            int nz=z+dz[i],ny=y+dy[i],nx=x+dx[i];
            if(visit[nz][ny][nx]==1 || nz<0 || ny <0 || nx <0 || nz>=5 || ny >=5 || nx >= 5) continue;
            if(nz==ez && ny==ey && nx==ex){
                ans=min(ans,cnt+1);
                return;
            }
            if(data[nz][ny][nx]==1){
                q.push(pp(p(nz,ny),p(nx,cnt+1)));
                visit[nz][ny][nx]=1;
            }
        }
    }
}
int main(){
    for(int i=0;i<5;i++)
        for(int j=0;j<5;j++)
            for(int w=0;w<5;w++)
                cin >> map[0][i][j][w];
    
    for(int i=0;i<5;i++)	//회전에 따른 좌표값...
        for(int t=1;t<4;t++)
            for(int j=0;j<5;j++)
                for(int w=0;w<5;w++)
                    map[t][i][4-w][j]=map[t-1][i][j][w];	
    
  
    int order[]={0,1,2,3,4};
    do{
        for(int i=0;i<1024;i++){
            int temp=i;
            for(int j=0;j<5;j++){   //중복 순열로 z값
                int val= temp%4;
                temp /=4;
                for(int q=0;q<5;q++){
                    for(int w=0;w<5;w++)
                        data[j][q][w]=map[val][order[j]][q][w];
                }
            }
            if(data[0][0][0]==1 && data[4][4][4]==1)
                bfs(0,0,0,4,4,4);
            if(data[0][0][4]==1 && data[4][4][0]==1)
                bfs(0,0,4,4,4,0);
            if(data[0][4][0]==1 && data[4][0][4]==1)
                bfs(0,4,0,4,0,4);
            if(data[0][4][4]==1 && data[4][0][0]==1)
                bfs(0,4,4,4,0,0);
            
        }
    }while(next_permutation(order,order+5));
    if(ans!=100000)
        cout << ans << endl;
    else
        cout << -1 << endl;
    
}
```


