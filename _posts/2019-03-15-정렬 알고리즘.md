---
layout:     post
title:      "정렬 알고리즘"
subtitle:   "선택,삽입,버블,퀵,병합 정렬에 대하여 알아보자"
date:       2019-03-22 19:56:00
author:     "kyoungIn"
header-type: "text"
tags:
    - 알고리즘
    - 취준

---



# 정렬 알고리즘 



## 선택 정렬(Selection sort)

기본이 되는 정렬 중 하나이다. <u>현재 위치에 들어갈 값을 찾아 정렬</u>하는 배열이다. 현재 위치에 저장될 값의 크기가 작냐, 크냐에 따라서 **최소 선택 정렬**(오름차순으로 정렬)과 **최대 선택 정렬**(내림차순으로 정렬)이 있다. 일반적으로 최소 선택 정렬이 쓰인다.

### 로직

1. 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째 인덱스 값과 바꿔준다.

2. 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 인덱스 값과 바꿔준다.

3. 위 과정을 반복하며 정렬을 수행한다.

   

   쉽게 말해서 모든 배열의 원소를 하나씩 기준으로 잡고 다른 모든 원소와 비교하며 작은 수를 앞으로 보내며 정렬하는 방법이다.배열이 어떻게 되어있든 전체를 모두 비교한다.

   구현은 간단하지만 매우 비효율적이다. **O(N^2)**의 시간복잡도를 가지고 있다. 공간 복잡도는 하나의 배열에서 하므로 **O(N)**.

### 장점

- 자료 이동 횟수가 미리 결정된다.

### 단점

- 안정성을 만족하지 않는다.
- 즉, 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다.

### 코드

```cpp
#include <iostream>
using namespace std;
int main(){
    int arr[5]={3,5,6,1,2};
    for(int i=0;i<4;i++){  // 0~3
        int min=i;
        for(int j=i;j<5;j++)  //i~4
            min = arr[min] > arr[j] ? j : min;
        int temp=arr[i];
        arr[i]=arr[min];
        arr[min]=temp;
    }
    for(int i=0;i<5;i++)
        cout << arr[i] << ' ';
}
```

https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html



## 삽입 정렬(Insertion sort)

손안의 카드를 정렬하는 방법과 유사하다. 새로운 카드를 기존의 정렬된 카드 사이의 올바른 자리를 찾아 삽입한다.
<u>새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬</u>된다.
자료 배열의 모든 요소를 앞에서부터 차례대로 **이미 정렬된 배열** 부분과 비교 하여, **자신의 위치를 찾아 삽입**함으로써 정렬을 완성한다.
매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.

### 로직

1. 두번째 인덱스부터 시작한다.

2. 앞 인덱스 자료들과 비교하여 삽입할 위치를 정한 뒤 자료를 뒤로 옮기고 지정한 자리에 삽입

   

   즉,  두번째자료는 첫번째자료와 비교, 세번째자료는 두번째,첫번째자료와 비교,,,한 뒤 그 자리에 자료를 삽입하기 위해 기존자료들을 한칸씩 뒤로 민다.

   시간복잡도는 최소 O(N), 최대 O(n^2)이므로 **O(N^2)**이고 공간복잡도는 하나의 배열에서 하므로 **O(N)**

### 장점

- 안정한 정렬 방법
- 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
- 대부분의 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.

### 단점

- 비교적 많은 레코드들의 이동을 포함한다.
- 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.

### 코드

```cpp
#include <iostream>
using namespace std;
int main(){
    int arr[5]={5,4,3,1,2};
    int i,j;
    for(i=1;i<5;i++){  // 0~3
        int key=arr[i];
        for(j=i-1;j>=0;j--){  //i~4
            if(arr[j]<=key) break;
            arr[j+1]=arr[j];
        }
        arr[j+1]=key;
    }
    for(int i=0;i<5;i++)
        cout << arr[i] << ' ';
}
```





## 버블 정렬(Bubble sort)

거품이 위로 올라가는 모양으로 정렬되서 버블정렬.
매번 연속된 두개의 인덱스를 비교해서,정한 기준(오름차순, 내림차순)에 따라 값을 뒤로 넘기며 정렬한다.(선택 정렬과 비슷)
오름차순 정렬할 경우 한바퀴를 돌면 최대값이 맨 끝 인덱스값으로 가있다.

1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

### 로직

1. 두번째 인덱스부터 시작하여 현재 인덱스의 값과 인접한 인덱스의 값을 비교
2. 만약 현재 값보다 크면 스왑
3. 현재 값이 더 크면 다음 인덱스의 비교로 넘어감
4. 이 과정을 전체배열의 크기 - 순환한 바퀴수 만큼 한다.

시간 복잡도는 **O(N^2)** , 공간 복잡도는 **O(N)

### 장점

- 구현이 매우 간단하다.

### 단점

- 순서에 맞지 않은 요소를 인접한 요소와 교환한다.
- 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
- 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.
- 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다.

### 코드

```cpp
#include <iostream>
using namespace std;
int main(){
    int arr[5]={5,4,3,2,1};
    int i,j;
    for(i=0;i<5;i++){  
        for(j=1;j<5-i;j++){  
            if(arr[j-1] > arr[j]){
                int temp= arr[j];
                arr[j]=arr[j-1];
                arr[j-1]=temp;
            }
        }
    }
    for(int i=0;i<5;i++)
        cout << arr[i] << ' ';
}
```



## 병합 정렬(Merge sort)

- ‘존 폰 노이만(John von Neumann)’이라는 사람이 제안한 방법

- 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬 에 속하며, 분할 정복 알고리즘의 하나 이다.

- 분할 정복(divide and conquer) 방법

  - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.

  - 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.

- **과정** **설명**

  - 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 

  - 그렇지 않은 경우에는정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.

  - 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.

  - 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

    

### 로직<오름차순>

1. 현재 배열을 반으로 쪼갠다. 배열의 시작위치와 종료위치를 더한 값에  2 나누어 기준점을 찾는다.
2. 계속 쪼개서 배열의 크기가 0또는 1일때까지 반복한다.
3. 두 배열 A,B를 비교한다. 각각의 인덱스를 i,j라고 가정했을때, i=A의 시작 인덱스, j=B의 시작인덱스 
4. A[i]와 B[j]를 비교 이 중 작은 값을 새로운 배열 C에 삽입한다.
5. 그리고 그 작은 값을 가지고 있던 배열 의 인덱스를 +1 해준다. 
6. 즉, A[i]가 더 작았다면 다음 비교는 A[i+1] 과 B[j] 이다.
7. 이 과정을 한 배열이 끝까지 도달할떄까지 반복한다.
8. 그러면 나머지 배열의 남은 값들을 배열 C에 차례대로 넣어준다.
9. C를 원래 배열에 저장한다.



병합정렬의 시간복잡도는 두 배열 A(n/2) B(n/2) 를 정렬하기때문에 O(n/2+n/2) -> O(n)이라고 할 수 있다.
분할과정은 lgN만큼 일어나는데, N크기의 배열을 분할하면 N/2 N/2로 2개 -> N/4 N/4 N/4 N/4 로 4개…,즉,분할 과정은 매번 반씩 감소하므로 lgN 만큼 반복해야 크기가 1인 배열로 분할 할 수 있다.

각 분할별로 병합을 진행하므로 전체의 시간복잡도는 **O(NlgN)** 이다.

![](https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort-concepts.png)

### 장점

- 안정적인 정렬 방법
- 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다.
- 만약 레코드를 연결 리스트(Linked List)로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
  - 제자리 정렬(in-place sorting)로 구현할 수 있다.
  - 따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 졍렬 방법보다 효율적이다.

### 단점

- 만약 레코드를 배열(Array)로 구성하면, 임시 배열이 필요하다.
- 제자리 정렬(in-place sorting)이 아니다.
- 레크드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.



### 코드

```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<int> v{21,10,12,20,25,13,15,22};
void Merge(int s,int e,int m){
    vector<int> temp(8);
    int i=s , j=m+1, idx=s;// idx:새로운 배열의 인덱스
    
    while(i<=m &&j <=e){
        if(v[i]<=v[j])
            temp[idx++]=v[i++];
        else
            temp[idx++]=v[j++];
    }
    if(i>m){
        for(int t=j;t<=e;t++)
            temp[idx++]=v[t];
    }
    else{
        for(int t=i;t<=m;t++)
            temp[idx++]=v[t];
    }
    
    for(int t=s;t<=e;t++)
        v[t]=temp[t];
}
void MergeSort(int s,int e){//start,end

    if(s>=e) return;
    
    int m = (s+e)/2;
    MergeSort(s,m);
    MergeSort(m+1,e);
    Merge(s,e,m);

}
int main(){
    MergeSort(0,7);
    for(int i=0;i<8;i++)
        cout << v[i] << ' ';
}
```



## 퀵 정렬(Quick sort)

- ‘찰스 앤터니 리처드 호어(Charles Antony Richard Hoare)’가 개발한 정렬 알고리즘
- 퀵 정렬은 불안정 정렬 에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬 에 속한다.
- 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법
- 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 비균등하게 분할한다
- 과정 설명
  - 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
  - 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (왼쪽원소 < 피벗 < 오른쪽원소 )
  - 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
  - 분할된 부분 리스트에 대하여 순환 호출 을 이용하여 정렬을 반복한다.
  - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
  - 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
  - 리스트의 크기가 0이나 1이 될 때까지 반복한다.



### 로직

- 피벗으로 잡을 값을 정한다.(맨 앞, 맨 뒤, 중간값, 랜덤값 중 선택)
- 배열의 맨 왼쪽원소를 left, 오른쪽원소를 right로 두고
- right 원소를 피벗과 비교하며 피벗보다 클 경우 right-1하고 다시 탐색 ,피벗보다 작을 경우 탐색을 멈춘다.
- left 원소를 피벗과 비교하며 피벗보다 작을 경우 left +1하고 다시 탐색, 피벗보다 클 경우 탐색을 멈춘다.
- left 원소와 right 원소를 스왑해준다.
- 위의 3,4,5과정을 left>right가 될때까지 반복해준다.
- 위 과정이 끝나면 피벗과 left를 바꿔준다.
- 다시 0~left-1 , left~끝까지로 나눠 정렬 시작.



각 배열의 정렬은 크기 N만큼 비교하고, 분할과정은 lgN만큼 진행하므로 **시간복잡도는 O(lgN)**
하지만 최악의 경우(모든 원소가 다 정렬 되어있는 경우) 에는 O(n^2)의 시간복잡도를 가지지만 거의 이런 경우는 없다.



### 장점

- 속도가 빠르다.
- 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
- 추가 메모리 공간을 필요로 하지 않는다.
- 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.

### 단점

- 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.

- 퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택한다.

  EX) 리스트 내의 몇 개의 데이터 중에서 크기순으로 중간 값(medium)을 피벗으로 선택한다

### 코드

```cpp
//3.퀵 정렬
#include <iostream>
#include <vector>
using namespace std;
vector<int> v{21,10,12,20,25,13,15,22};
void QuickSort(int s,int e){
    if(s>=e) return;
  
    int pivot=v[s];
    int left=s+1,right=e;
    while(left<=right){//엇갈릴때까지
        while(v[left]<pivot && left<=e)
            left++;
        while(v[right]>pivot && s+1<=right)
            right--;
        
        if(left>right){//엇갈림
           swap(v[s],v[right]);
        }
        else{
            swap(v[left],v[right]);
        }
    }//while 	
  
    QuickSort(s,right-1);
    QuickSort(right+1,e);
}
int main(){
    QuickSort(0,7);
    for(int i=0;i<8;i++)
        cout << v[i] << ' ';
}
```

